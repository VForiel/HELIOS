# Agent Log 2025.11.30-05: Layer/Element Architecture Refactoring

**Date:** 2025-11-30  
**Type:** Major Architecture Refactoring  
**Status:** In Progress (Phase 1 Complete)

## Motivation

L'utilisateur a identifié une incohérence architecturale majeure dans HELIOS :

**Problème actuel :**
- La classe `Layer` fait office d'élément unique
- Pour avoir des éléments parallèles, on passe une **liste de `Layer`** à `Context.add_layer()`
- Incohérence : `TelescopeArray` est un `Layer` contenant des `Collector` (objets de données), mais pour plusieurs caméras, on fait `ctx.add_layer([camera1, camera2])` (liste de Layers)
- Manque de cohérence conceptuelle entre "niveau logique" et "composant physique"

**Solution proposée :**
```
Context
└── layers: List[Layer]
    └── Layer (niveau logique)
        └── elements: List[Element] (composants physiques parallèles)
            └── Element (classe de base)
                ├── CelestialBody (Star, Planet, Zodiacal, ExoZodiacal)
                ├── Collector (telescope aperture)
                ├── OpticalElement (Atmosphere, AO, Coronagraph, BeamSplitter)
                └── DetectorElement (Camera)
```

## Avantages de la Nouvelle Architecture

1. **Cohérence conceptuelle**
   - **Layer** = Niveau logique dans le pipeline de simulation (Scene, Optics, Detectors)
   - **Element** = Composant physique individuel (Star, Telescope, Camera)
   - Tous les éléments parallèles sont traités de la même façon

2. **Clarté du code**
   - Distinction claire entre organisation du pipeline (layers) et composants physiques (elements)
   - Plus facile de comprendre qu'un `Layer` contient plusieurs `Elements` parallèles

3. **Flexibilité accrue**
   - Facilite l'ajout de plusieurs éléments parallèles de n'importe quel type
   - Architecture extensible pour futures fonctionnalités

4. **Uniformité**
   - `Scene` contient des `CelestialBody` elements
   - `TelescopeArray` contient des `Collector` elements  
   - `DetectorLayer` contiendra des `Camera` elements
   - Même pattern partout !

## Phase 1 : Core Classes (COMPLETED)

### 1. Nouvelle classe `Element` (base pour tous les composants)

**File:** `src/helios/core/context.py`

```python
class Element:
    """
    Base class for all simulation elements (physical components).
    
    An Element represents a physical component in the optical system that can
    process wavefronts independently. Elements are grouped within Layers for
    parallel processing.
    """
    def __init__(self, name: Optional[str] = None):
        self.name = name

    def process(self, wavefront: Any, context: 'Context') -> Any:
        """Process the incoming wavefront/signal and return the result."""
        raise NotImplementedError("Subclasses must implement process()")
```

**Key features:**
- Tous les composants physiques héritent d'`Element`
- Méthode `process()` obligatoire pour traiter les wavefronts
- Attribut `name` pour identification (utile pour diagrammes UML)

### 2. Refactorisation de `Layer`

**File:** `src/helios/core/context.py`

```python
class Layer:
    """
    Base class for all simulation layers (logical grouping of elements).
    
    A Layer represents a logical stage in the simulation pipeline and contains
    one or more Elements that process wavefronts in parallel.
    """
    def __init__(self, name: Optional[str] = None):
        self.name = name
        self.elements: List[Element] = []

    def add_element(self, element: Element):
        """Add an element to this layer."""
        self.elements.append(element)

    def process(self, wavefront: Any, context: 'Context') -> Any:
        """
        Process through all elements in this layer.
        
        - Single element: process directly
        - Multiple elements: process in parallel, return list of outputs
        """
        if len(self.elements) == 0:
            return wavefront
        
        if len(self.elements) == 1:
            return self.elements[0].process(wavefront, context)
        
        # Multiple elements - process in parallel
        outputs = []
        for element in self.elements:
            wf_copy = copy.deepcopy(wavefront) if wavefront is not None else None
            outputs.append(element.process(wf_copy, context))
        
        return outputs
```

**Key changes:**
- `Layer` contient maintenant `self.elements: List[Element]`
- Méthode `add_element()` pour ajouter des éléments
- Méthode `process()` par défaut qui traite les éléments en parallèle
- Les sous-classes peuvent surcharger `process()` pour une logique personnalisée

### 3. Migration de `CelestialBody` → `Element`

**File:** `src/helios/components/scene.py`

**Avant:**
```python
class CelestialBody:
    def __init__(self, position=..., **kwargs):
        self.position = position
        self.kwargs = kwargs
```

**Après:**
```python
class CelestialBody(Element):
    def __init__(self, position=..., name=None, **kwargs):
        super().__init__(name=name)
        self.position = position
        self.kwargs = kwargs
    
    def process(self, wavefront, context):
        # Default: pass-through (Scene layer handles combination)
        return wavefront
```

**Changes:**
- Hérite d'`Element` au lieu d'être une classe autonome
- Appelle `super().__init__(name=name)` pour initialiser Element
- Ajout de la méthode `process()` (par défaut pass-through)
- Import mis à jour : `from ..core.context import Element`

### 4. Migration de `Scene` Layer

**File:** `src/helios/components/scene.py`

**Avant:**
```python
class Scene(Layer):
    def __init__(self, distance=10*u.pc, name=None):
        self.distance = distance
        self.name = name
        self.objects = []
        super().__init__()
    
    def add(self, obj: CelestialBody):
        self.objects.append(obj)
```

**Après:**
```python
class Scene(Layer):
    def __init__(self, distance=10*u.pc, name=None):
        super().__init__(name=name or "Scene")
        self.distance = distance
        # self.elements inherited from Layer
    
    def add(self, obj: CelestialBody):
        self.add_element(obj)  # Use Layer's add_element method
        if isinstance(obj, Planet) and obj.scene is None:
            obj.scene = self
    
    @property
    def objects(self):
        """Backward compatibility: alias for elements."""
        return self.elements
```

**Key changes:**
- Appelle `super().__init__(name=...)` pour initialiser Layer avec nom
- Utilise `self.add_element()` au lieu de `self.objects.append()`
- Propriété `objects` pour compatibilité ascendante (alias de `elements`)
- Les méthodes `render()` et `plot()` continuent de fonctionner via l'alias

### 5. Migration de `Collector` → `Element`

**File:** `src/helios/components/collector.py`

**Avant:**
```python
class Collector:
    def __init__(self, pupil, position=(0,0), size=None, name=None, **metadata):
        self.pupil = pupil
        self.position = position
        self.size = size
        self.name = name
        self.metadata = metadata
```

**Après:**
```python
class Collector(Element):
    def __init__(self, pupil, position=(0,0), size=None, name=None, **metadata):
        default_name = f"Collector@({position[0]:.1f},{position[1]:.1f})"
        super().__init__(name=name or default_name)
        
        self.pupil = pupil
        self.position = tuple(position)
        self.size = size  # (size inference logic)
        self.metadata = metadata
    
    def process(self, wavefront, context):
        """Apply this collector's pupil mask to wavefront."""
        if wavefront is None or not hasattr(wavefront, 'field'):
            return wavefront
        
        try:
            N = wavefront.field.shape[0]
            mask = self.pupil.get_array(npix=N, soft=True)
            wavefront.field = wavefront.field * mask.astype(wavefront.field.dtype)
        except Exception:
            pass  # Skip if pupil can't be rendered
        
        return wavefront
```

**Key changes:**
- Hérite d'`Element`
- Appelle `super().__init__(name=...)` 
- Ajout de la méthode `process()` qui applique le masque de pupille
- Import mis à jour : `from ..core.context import Element`

### 6. Migration de `TelescopeArray` Layer

**File:** `src/helios/components/collector.py`

**Avant:**
```python
class TelescopeArray(Layer):
    def __init__(self, name=None, latitude=0*u.deg, ...):
        super().__init__()
        self.name = name or "TelescopeArray"
        self.collectors = []
    
    def add_collector(self, pupil, position=(0,0), ...):
        collector = Collector(...)
        self.collectors.append(collector)
```

**Après:**
```python
class TelescopeArray(Layer):
    def __init__(self, name=None, latitude=0*u.deg, ...):
        super().__init__(name=name or "TelescopeArray")
        self.latitude = latitude
        # self.elements inherited from Layer
    
    @property
    def collectors(self):
        """Backward compatibility: alias for elements."""
        return self.elements
    
    def add_collector(self, pupil, position=(0,0), ...):
        collector = Collector(...)
        self.add_element(collector)  # Use Layer's add_element method
```

**Key changes:**
- Appelle `super().__init__(name=...)` pour initialiser Layer
- Propriété `collectors` pour compatibilité (alias de `elements`)
- Utilise `self.add_element()` au lieu de `self.collectors.append()`
- Méthode `process()` surchargée pour combiner les pupils correctement
  - Mode télescope unique : combine multiplicativement au centre
  - Mode interférométrique : positionne chaque pupil à sa baseline

**Process() override logic:**
```python
def process(self, wavefront, context):
    """Override Layer.process() for custom pupil combination."""
    if not is_interferometric:
        # Co-located: multiply pupils at center
        total_mask = product of all collector.pupil masks
    else:
        # Interferometric: position each pupil at baseline coordinates
        for collector in self.elements:
            shift pupil to collector.position
            add to combined_mask
    
    wavefront.field *= combined_mask
    return wavefront
```

### 7. Exports mis à jour

**File:** `src/helios/__init__.py`

```python
# Expose core components
from .core.context import Context, Layer, Element  # Added Element
```

```python
__all__ = [
    'Context', 'Layer', 'Element',  # Added Element
    ...
]
```

## Compatibilité Ascendante

Toutes les modifications incluent des mécanismes de compatibilité :

1. **`Scene.objects`** → Propriété alias de `Scene.elements`
2. **`TelescopeArray.collectors`** → Propriété alias de `TelescopeArray.elements`
3. **API utilisateur inchangée** :
   - `scene.add(star)` continue de fonctionner
   - `telescope.add_collector(...)` continue de fonctionner
   - Méthodes `render()`, `plot()`, etc. inchangées

## Phase 2 : Remaining Components (TODO)

### Composants à migrer :

1. **Camera** (detectors.py)
   - `Camera` devient `CameraElement(Element)`
   - Créer `DetectorLayer(Layer)` qui contient des `CameraElement`
   - Ou bien garder `Camera` comme Layer simple avec un seul element interne

2. **Atmosphere, AdaptiveOptics** (atmosphere.py)
   - Ces composants sont généralement uniques (pas parallèles)
   - Deviennent soit `Element` dans un `OpticsLayer`
   - Ou gardent leur structure actuelle de Layer simple

3. **Coronagraph** (coronagraph.py)
   - Composant unique généralement
   - Devient `CoronagraphElement(Element)` ou garde Layer simple

4. **BeamSplitter** (beam_splitter.py)
   - Cas spécial : crée des chemins parallèles
   - Logique à revoir pour nouvelle architecture

5. **PhotonicChip, TOPS, MMI** (photonics.py)
   - À évaluer selon usage

### Context.observe() à mettre à jour

La méthode `Context.observe()` traite actuellement des `Layer` ou des listes de `Layer`. 
Avec la nouvelle architecture, elle doit :
- Traiter chaque `Layer` séquentiellement
- Chaque `Layer.process()` gère ses `Element`s en interne

**Current logic (to update):**
```python
def observe(self):
    current_signal = None
    for layer in self.layers:
        if isinstance(layer, list):
            # Parallel layers - process each
            outputs = [sub_layer.process(...) for sub_layer in layer]
            current_signal = outputs
        else:
            current_signal = layer.process(current_signal, self)
    return current_signal
```

**New logic:**
```python
def observe(self):
    current_signal = None
    for layer in self.layers:
        # Each layer handles its own elements internally
        current_signal = layer.process(current_signal, self)
    return current_signal
```

Plus simple ! Plus besoin de traiter les listes de Layers.

### UML Diagram à mettre à jour

La fonction `plot_uml_diagram()` doit être adaptée pour :
- Afficher les `Layer` comme boîtes principales
- Afficher les `Element` à l'intérieur de chaque Layer
- Notation `[layer, element]` pour l'indexation

## Tests à Mettre à Jour

Tous les tests qui utilisent l'ancienne architecture doivent être vérifiés :
- `tests/test_helios.py` - Pipeline complet
- `tests/test_telescope_presets.py` - VLTI, LIFE
- `tests/test_collectors_process.py` - TelescopeArray
- Tests de scene, etc.

Grâce aux alias de compatibilité, la plupart devraient fonctionner sans changement.

## Validation Required

Avant de considérer cette refonte terminée :

1. ✅ Phase 1 (Core + Scene + Telescope) - COMPLETED
2. ⏳ Phase 2 (Camera, Optics) - TODO
3. ⏳ Update Context.observe() - TODO
4. ⏳ Update plot_uml_diagram() - TODO
5. ⏳ Run all tests - TODO
6. ⏳ Update demo.ipynb - TODO
7. ⏳ Update documentation - TODO

## Breaking Changes

**None expected** - Full backward compatibility maintained through:
- Property aliases (`objects`, `collectors`)
- Unchanged public APIs (`add()`, `add_collector()`)
- Existing methods continue to work

**Internal changes only:**
- Inheritance hierarchy updated
- Internal storage (`elements` instead of `objects`/`collectors`)
- Processing logic unified

## Migration Guide for Future Development

### Adding new Element types:

```python
class MyElement(Element):
    def __init__(self, param1, name=None):
        super().__init__(name=name or "MyElement")
        self.param1 = param1
    
    def process(self, wavefront, context):
        # Transform wavefront
        return wavefront
```

### Adding new Layer types:

```python
class MyLayer(Layer):
    def __init__(self, name=None):
        super().__init__(name=name or "MyLayer")
    
    def add_my_element(self, ...):
        element = MyElement(...)
        self.add_element(element)
    
    # Optional: override process() for custom combination logic
    def process(self, wavefront, context):
        # Custom logic for combining elements
        return super().process(wavefront, context)  # Or custom implementation
```

### Using in Context:

```python
ctx = helios.Context()

# Add layer with single element
layer1 = MyLayer()
layer1.add_my_element(...)
ctx.add_layer(layer1)

# Add layer with multiple parallel elements
layer2 = MyLayer()
layer2.add_my_element(...)
layer2.add_my_element(...)  # Parallel processing
ctx.add_layer(layer2)

# Run simulation
result = ctx.observe()
```

## Conclusion Phase 1

Cette première phase établit les fondations de la nouvelle architecture Layer/Element.
Les classes `Element` et `Layer` sont créées, et les composants Scene/CelestialBody 
et TelescopeArray/Collector sont migrés avec succès.

La compatibilité ascendante est maintenue via des propriétés alias, permettant
au code existant de continuer à fonctionner sans modification.

Les phases suivantes migreront les composants restants et mettront à jour
Context.observe() et plot_uml_diagram() pour tirer pleinement parti de la
nouvelle architecture.

**Status: Phase 1 Complete ✓**
